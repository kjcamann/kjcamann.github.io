<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lists Quick Start Guide &mdash; CSD 2021.1-alpha documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Why Intrusive Lists?" href="lists-rationale.html" />
    <link rel="prev" title="Lists Library" href="lists-main.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CSD
            <img src="_static/csd-logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2021.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="intrusive-main.html">Intrusive Container Utilities</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="lists-main.html">Lists Library</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Lists Quick Start Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="lists-rationale.html">Why Intrusive Lists?</a></li>
<li class="toctree-l2"><a class="reference internal" href="lists-queue-and-stl.html">How CSD merges the <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> and STL container designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="lists-reference.html">Lists Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="lists-implementation.html">CSD lists implementation notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utility-main.html">Utility Libraries</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CSD</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="lists-main.html">Lists Library</a> &raquo;</li>
      <li>Lists Quick Start Guide</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/lists-guide.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="lists-quick-start-guide">
<h1>Lists Quick Start Guide<a class="headerlink" href="#lists-quick-start-guide" title="Permalink to this headline"></a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#what-are-csd-lists" id="id6">What are CSD lists?</a></p></li>
<li><p><a class="reference internal" href="#a-simple-example" id="id7">A simple example</a></p></li>
<li><p><a class="reference internal" href="#where-do-i-find-the-api-documentation" id="id8">Where do I find the API documentation?</a></p></li>
<li><p><a class="reference internal" href="#choosing-the-template-parameters" id="id9">Choosing the template parameters</a></p>
<ul>
<li><p><a class="reference internal" href="#choosing-the-entryex-parameter" id="id10">Choosing the EntryEx parameter</a></p>
<ul>
<li><p><a class="reference internal" href="#syntactic-sugar-for-declaring-extractors" id="id11">Syntactic sugar for declaring extractors</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#choosing-the-sizemember-parameter" id="id12">Choosing the SizeMember parameter</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#understanding-the-head-vs-fwd-head-proxy-templates" id="id13">Understanding the <code class="docutils literal notranslate"><span class="pre">head</span></code> vs <code class="docutils literal notranslate"><span class="pre">fwd_head</span> <span class="pre">+</span> <span class="pre">proxy</span></code> templates</a></p>
<ul>
<li><p><a class="reference internal" href="#are-fwd-head-instances-movable" id="id14">Are <code class="docutils literal notranslate"><span class="pre">fwd_head</span></code> instances movable?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#understand-the-csd-list-concepts" id="id15">Understand the CSD list concepts</a></p></li>
</ul>
</div>
<section id="what-are-csd-lists">
<h2><a class="toc-backref" href="#id6">What are CSD lists?</a><a class="headerlink" href="#what-are-csd-lists" title="Permalink to this headline"></a></h2>
<p>CSD lists are intrusive linked lists based on the <a class="reference external" href="https://man.openbsd.org/queue.3">BSD queue(3) library</a>. That library first appeared in 4.4 BSD, and is available today on most UNIX systems via the header file <code class="docutils literal notranslate"><span class="pre">&lt;sys/queue.h&gt;</span></code> (it is also included in glibc and can be found on most Linux systems). Linked lists are used to implement queues in various UNIX kernels, thus the name “queue.”</p>
<p>The original queue library has been copied into or reimplemented in many well-known C code bases, including the Linux kernel. Like most data structure libraries written in C, it relies on macros to achieve static polymorphism. CSD lists are C++20 re-implementations that combine the data structure design from BSD queues with the design of STL containers. For example, it achieves static polymorphism using templates instead of macros.</p>
<p>To learn why intrusive linked lists are great data structures, read <a class="reference internal" href="lists-rationale.html"><span class="doc">Why Intrusive Lists?</span></a></p>
<p>CSD provides the four data structures from <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code>:</p>
<dl class="field-list">
<dt class="field-odd">slist</dt>
<dd class="field-odd"><p>Singly-linked lists</p>
</dd>
<dt class="field-even">stailq</dt>
<dd class="field-even"><p>Singly-linked tail queues; a “tail queue” is a list that keeps track of the last element, which allows fast insertion at the end of the list and fast list concatenation</p>
</dd>
<dt class="field-odd">tailq</dt>
<dd class="field-odd"><p>Doubly-linked tail queues, i.e., doubly-linked lists that also have the tail queue features</p>
</dd>
<dt class="field-even">list</dt>
<dd class="field-even"><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>list is deprecated and should be avoided.</p>
</div>
<p>In the original <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> library, there is a difference between a <code class="docutils literal notranslate"><span class="pre">LIST</span></code> and a <code class="docutils literal notranslate"><span class="pre">TAILQ</span></code>, but in CSD there is not. To meet the design goal of matching the STL, the C++ implementation of lists and tailqs must be exactly the same (see <a class="reference internal" href="lists-queue-and-stl.html#lists-diff-with-queue"><span class="std std-ref">here</span></a> for a detailed explanation). If <code class="docutils literal notranslate"><span class="pre">&lt;csg/core/list.h&gt;</span></code> is included, it makes lists available as tailq type aliases, but adds deprecation attributes.</p>
</dd>
</dl>
</section>
<section id="a-simple-example">
<h2><a class="toc-backref" href="#id7">A simple example</a><a class="headerlink" href="#a-simple-example" title="Permalink to this headline"></a></h2>
<div class="highlight-c++ notranslate" id="lists-main-example"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;csg/core/slist.h&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">csg</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">ListItem</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">                        </span><span class="c1">// List item&#39;s data</span>
<span class="w">  </span><span class="n">slist_entry</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="w"> </span><span class="n">link</span><span class="p">;</span><span class="w">   </span><span class="c1">// Intrusive link that makes us part of</span>
<span class="w">                                </span><span class="c1">// a `ListItem` singly-linked list</span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// The head of the list is a class template. The second template</span>
<span class="c1">// parameter is a functor that controls how the list locates the</span>
<span class="c1">// intrusive links inside the list items (in this case, via using</span>
<span class="c1">// a pointer-to-data-member access). Because this template is somewhat</span>
<span class="c1">// verbose, a number of helper macros and type aliases are available;</span>
<span class="c1">// these are explained later in the documentation.</span>
<span class="k">using</span><span class="w"> </span><span class="n">list_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slist_head</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">  </span><span class="n">ListItem</span><span class="p">,</span><span class="w">                               </span><span class="c1">// Type of items in list</span>
<span class="w">  </span><span class="n">invocable_constant</span><span class="o">&lt;&amp;</span><span class="n">ListItem</span><span class="o">::</span><span class="n">link</span><span class="o">&gt;</span><span class="p">,</span><span class="w">    </span><span class="c1">// How to access list links</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span><span class="w">                           </span><span class="c1">// Type for `size()`</span>

<span class="c1">// Create an empty list and two items, then add the items to the list.</span>
<span class="n">list_t</span><span class="w"> </span><span class="n">L</span><span class="p">;</span><span class="w"></span>
<span class="n">ListItem</span><span class="w"> </span><span class="n">item1</span><span class="p">{.</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="n">item2</span><span class="p">{.</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span><span class="w"></span>

<span class="n">L</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item2</span><span class="p">);</span><span class="w"> </span><span class="c1">// Note: insertion by pointer. This is explained</span>
<span class="n">L</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item1</span><span class="p">);</span><span class="w"> </span><span class="c1">// in the next section of this guide.</span>

<span class="c1">// Print the items.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ListItem</span><span class="w"> </span><span class="o">&amp;</span><span class="nl">item</span> <span class="p">:</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;This is item #&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>This will print</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This is item #1
This is item #2
</pre></div>
</div>
</section>
<section id="where-do-i-find-the-api-documentation">
<span id="lists-where-are-the-docs"></span><h2><a class="toc-backref" href="#id8">Where do I find the API documentation?</a><a class="headerlink" href="#where-do-i-find-the-api-documentation" title="Permalink to this headline"></a></h2>
<p>There is deliberately very little doxygen documentation for CSD list member functions. They are meant to follow the standard C++ list APIs as much as possible, so you should use your favorite C++ reference (e.g., <a class="reference external" href="https://cppreference.com">cppreference</a>) for <a class="reference external" href="https://cppreference.com/w/cpp/container/list">&lt;list&gt;</a> when referencing tailq and <a class="reference external" href="https://cppreference.com/w/cpp/container/forward_list">&lt;forward_list&gt;</a> when referencing slist or stailq.</p>
<p>However, because CSD lists are intrusive and because they follow the BSD data structure design patterns, there are some differences in the public API compared to standard C++ containers. The fundamental difference is that CSD lists – like all intrusive data structures – do not own their elements. A “list” consists of a small “head” object which points to the first (and possibly last) item in the list. The items themselves have a lifetime distinct from the list head’s lifetime and are allocated elsewhere, usually in a memory pool. An illustration of a CSD <code class="docutils literal notranslate"><span class="pre">slist</span></code> is shown below:</p>
<figure class="align-default" id="id4">
<a class="reference external image-reference" href="_images/lists-guide-concept.png"><img alt="CSD slist datastructure diagram" src="_images/lists-guide-concept.png" /></a>
<figcaption>
<p><span class="caption-text">A CSD list object is little more than a pointer to the intial item; the items are <em>not</em> owned by the list, they are only linked into it (click to enlarge).</span><a class="headerlink" href="#id4" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Compare this with node-based lists, like <code class="docutils literal notranslate"><span class="pre">std::forward_list</span></code>, which own their elements and store them in “node” containers that are allocated by the list itself. One possible implementation of this design is illustrated below:</p>
<figure class="align-default" id="id5">
<a class="reference external image-reference" href="_images/lists-node-list.png"><img alt="A typical node-based list datastructure" src="_images/lists-node-list.png" /></a>
<figcaption>
<p><span class="caption-text">A typical node-based list (i.e., a non-intrusive list) has ownership over the elements, which are typically wrapped inside node objects. The lifetime of node objects is explicitly managed by the list itself (click to enlarge).</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>This fundamental difference gives rise to a variety of smaller API differences, be sure to read the section <a class="reference internal" href="lists-queue-and-stl.html#lists-diff-with-stl"><span class="std std-ref">Differences between CSD lists and other STL containers</span></a> for all the details. In short, the differences are:</p>
<ul class="simple">
<li><p>CSD lists cannot be copied.</p></li>
<li><p>List items are neither copied nor moved into the list – they are just linked into it (their intrusive link member variable is modified to splice the item into the list).</p></li>
<li><p>As a consequence of the above, list items are always inserted <em>by pointer</em>, i.e., for a list of type <code class="docutils literal notranslate"><span class="pre">T</span></code>, the insert family of functions require a <code class="docutils literal notranslate"><span class="pre">T*</span></code> value. To avoid breaking with the standard containers too much, all <em>non-insertion</em> member functions continue to use <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>, e.g., <code class="docutils literal notranslate"><span class="pre">front()</span></code> and <code class="docutils literal notranslate"><span class="pre">back()</span></code> continue to return a reference to the item, not a pointer to it.</p></li>
<li><p>A list item cannot be added to multiple lists that use the same entry link.</p></li>
<li><p>The list destructor doesn’t actually destroy the items (because it does not own them).</p></li>
</ul>
<p>CSD lists also provide some useful APIs which are not in the standard containers – see <a class="reference internal" href="lists-queue-and-stl.html#lists-extra-methods"><span class="std std-ref">Methods in CSD lists that do not exist in the STL</span></a>.</p>
</section>
<section id="choosing-the-template-parameters">
<h2><a class="toc-backref" href="#id9">Choosing the template parameters</a><a class="headerlink" href="#choosing-the-template-parameters" title="Permalink to this headline"></a></h2>
<p>As can be seen in the <a class="reference internal" href="#lists-main-example"><span class="std std-ref">example above</span></a> <code class="docutils literal notranslate"><span class="pre">slist_head</span></code> has three template parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">T</dt>
<dd class="field-odd"><p>The type of the items in the list.</p>
</dd>
<dt class="field-even">EntryEx</dt>
<dd class="field-even"><p>The type of function object that extracts the intrusive link, given an instance of <code class="docutils literal notranslate"><span class="pre">T</span></code>. In the example above, the intrusive link is the data member <code class="docutils literal notranslate"><span class="pre">csg::slist_entry&lt;ListItem&gt;</span> <span class="pre">link</span></code>. The link object is called an “entry” from the name of the corresponding <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> macros, e.g., <code class="docutils literal notranslate"><span class="pre">SLIST_ENTRY</span></code>. See <a class="reference internal" href="#lists-how-to-choose-extractor"><span class="std std-ref">Choosing the EntryEx parameter</span></a> for more information.</p>
</dd>
<dt class="field-odd">SizeMember</dt>
<dd class="field-odd"><p>The C++ standard container <code class="docutils literal notranslate"><span class="pre">&lt;list&gt;</span></code> offers <span class="math notranslate nohighlight">\(O(1)\)</span> access to its size by storing the list size inline and maintaining it during each modifying operation. The C++ standard container <code class="docutils literal notranslate"><span class="pre">&lt;forward_list&gt;</span></code>, and the BSD <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> library do not track list size – getting the size is an <span class="math notranslate nohighlight">\(O(n)\)</span> operation that fully traverses the list to count each item. CSD lists allow the user to choose which behavior they want. See <a class="reference internal" href="#lists-how-to-choose-sizetype"><span class="std std-ref">Choosing the SizeMember parameter</span></a> for more information.</p>
</dd>
</dl>
<section id="choosing-the-entryex-parameter">
<span id="lists-how-to-choose-extractor"></span><h3><a class="toc-backref" href="#id10">Choosing the EntryEx parameter</a><a class="headerlink" href="#choosing-the-entryex-parameter" title="Permalink to this headline"></a></h3>
<p>All intrusive data structures in CSD are parameterized by a template parameter called an <em>extractor</em> – in this case an <strong>Entry Ex</strong>tractor – that knows how to extract the intrusive book-keeping object from the user’s type.</p>
<p>Extractors are covered in detail in <a class="reference internal" href="intrusive-extractors.html"><span class="doc">Extractors: the Core Intrusive Concept</span></a>. That document explains the rationale for extractors and gives advice on how to define them. Below we cover the most common “syntactic sugar” way to declare the two main types of extractors: <code class="docutils literal notranslate"><span class="pre">offsetof</span></code>-based and <code class="docutils literal notranslate"><span class="pre">invocable_constant</span></code>-based.</p>
<section id="syntactic-sugar-for-declaring-extractors">
<h4><a class="toc-backref" href="#id11">Syntactic sugar for declaring extractors</a><a class="headerlink" href="#syntactic-sugar-for-declaring-extractors" title="Permalink to this headline"></a></h4>
<p>Because the list head templates are so verbose – mainly because of the extractor parameter – CSD provides helper alias templates and macros. Ideally we would not use any macros, but code patterns involving <code class="docutils literal notranslate"><span class="pre">offsetof</span></code> typically cannot be expressed without resorting to macros.</p>
<p>For offsetof-based extractors:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ListItem</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">slist_entry</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="w"> </span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Instead of this...</span>
<span class="k">using</span><span class="w"> </span><span class="n">my_list_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slist_head</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">    </span><span class="n">ListItem</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">offset_extractor</span><span class="o">&lt;</span><span class="n">slist_entry</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">offsetof</span><span class="p">(</span><span class="n">ListItem</span><span class="p">,</span><span class="w"> </span><span class="n">link</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>

<span class="c1">// ...write this:</span>
<span class="k">using</span><span class="w"> </span><span class="n">my_list_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CSG_TAILQ_HEAD_OFFSET_T</span><span class="p">(</span><span class="n">ListItem</span><span class="p">,</span><span class="w"> </span><span class="n">link</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>For most constexpr-invocable extractors – usually pointer-to-member based – we can use a helper type alias:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ListItem</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">slist_entry</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="w"> </span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Instead of this...</span>
<span class="k">using</span><span class="w"> </span><span class="n">my_list_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slist_head</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">    </span><span class="n">ListItem</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">invocable_constant</span><span class="o">&lt;&amp;</span><span class="n">ListItem</span><span class="o">::</span><span class="n">link</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>

<span class="c1">// ...write this:</span>
<span class="k">using</span><span class="w"> </span><span class="n">my_list_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slist_head_cinvoke_t</span><span class="o">&lt;&amp;</span><span class="n">ListItem</span><span class="o">::</span><span class="n">link</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Ideally, this helper alias would work with all invocables, not just constexpr ones. Unfortunately as of C++20, there is no “invocation traits” class that would allow us to discover the type of the first argument to the invocable, no matter what form it has. As of C++17, <em>constexpr</em> invocables can take a limited number of forms (free functions, member function pointers, etc.) and a traits class is provided that partially specializes all known syntactic forms and exposes the argument type. This won’t cover the additional constexpr invocables that were added in C++20 unfortunately (constexpr non-type arguments, e.g., a constexpr lambda extractor). For cases that are not covered, the user must resort to the verbose declaration.</p>
</section>
</section>
<section id="choosing-the-sizemember-parameter">
<span id="lists-how-to-choose-sizetype"></span><h3><a class="toc-backref" href="#id12">Choosing the SizeMember parameter</a><a class="headerlink" href="#choosing-the-sizemember-parameter" title="Permalink to this headline"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">SizeMember</span></code> parameter can either be an integral type (in which case, the internal size member will be a field of that type) or it can be the special type <code class="docutils literal notranslate"><span class="pre">csg::no_size</span></code>, which removes the size member and gives the <span class="math notranslate nohighlight">\(O(n)\)</span> behavior.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">csg::no_size</span></code> option is more in-keeping with historical BSD design because typically, the size of most lists will not be greater than the maximum value of <code class="docutils literal notranslate"><span class="pre">std::uint32_t</span></code>. However, if <code class="docutils literal notranslate"><span class="pre">SizeMember</span></code> is actually set to <code class="docutils literal notranslate"><span class="pre">std::uint32_t</span></code>, the user will probably waste 4 bytes of tail padding unless they are careful to pack small members directly after the list head object. It will not be immediately clear from the code that valuable cache line space might be being wasted, so <code class="docutils literal notranslate"><span class="pre">csg::no_size</span></code> is generally preferred. For this reason, <code class="docutils literal notranslate"><span class="pre">no_size</span></code> is also the default template argument for <code class="docutils literal notranslate"><span class="pre">SizeMember</span></code>, hence why it is unspecified in most of the later examples.</p>
<p>Because the list’s items are typically allocated from a pool allocator, there is usually a factory function which allocates items and places them on lists – this is a natural place for the user’s own size maintenance code.</p>
</section>
</section>
<section id="understanding-the-head-vs-fwd-head-proxy-templates">
<span id="lists-head-vs-fwd-head"></span><h2><a class="toc-backref" href="#id13">Understanding the <code class="docutils literal notranslate"><span class="pre">head</span></code> vs <code class="docutils literal notranslate"><span class="pre">fwd_head</span> <span class="pre">+</span> <span class="pre">proxy</span></code> templates</a><a class="headerlink" href="#understanding-the-head-vs-fwd-head-proxy-templates" title="Permalink to this headline"></a></h2>
<p>Suppose you want to create a CSD singly-linked list (slist) head. You have two options:</p>
<ol class="arabic simple">
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">slist_head</span></code> class template</p></li>
<li><p>Use a combination of the <code class="docutils literal notranslate"><span class="pre">slist_fwd_head</span></code> and <code class="docutils literal notranslate"><span class="pre">slist_proxy</span></code> class templates</p></li>
</ol>
<p>Consider this code from the example above:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ListItem</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">slist_entry</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="w"> </span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">using</span><span class="w"> </span><span class="n">list_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slist_head</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">  </span><span class="n">ListItem</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">invocable_constant</span><span class="o">&lt;&amp;</span><span class="n">ListItem</span><span class="o">::</span><span class="n">link</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Note that the expression <code class="docutils literal notranslate"><span class="pre">&amp;ListItem::link</span></code> requires <code class="docutils literal notranslate"><span class="pre">ListItem</span></code> to be a complete type. <a class="footnote-reference brackets" href="#lists-complete-type" id="id1">1</a> This means that the <code class="docutils literal notranslate"><span class="pre">list_t</span></code> type alias cannot be declared before the <code class="docutils literal notranslate"><span class="pre">ListItem</span></code> type is defined, nor can any instance of the list. That is, the following does <em>not</em> work:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ListItem</span><span class="p">;</span><span class="w"></span>

<span class="k">using</span><span class="w"> </span><span class="n">list_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slist_head</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">  </span><span class="n">ListItem</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">invocable_constant</span><span class="o">&lt;&amp;</span><span class="n">ListItem</span><span class="o">::</span><span class="n">link</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="c1">// Error: incomplete type in nested-name specifier</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Definition is below, but it&#39;s too late!</span>
<span class="k">struct</span> <span class="nc">ListItem</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">slist_entry</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="w"> </span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>This restriction did not exist in the original <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> C library. In exchange, the <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> equivalent of the “entry extractor” (the name of the field for the “entry” object) has to be specified in almost <em>every</em> macro that accesses the list, e.g., the <code class="docutils literal notranslate"><span class="pre">link</span></code> field name would need to be specified when performing an insert: <code class="docutils literal notranslate"><span class="pre">SLIST_INSERT_AFTER(item_before,</span> <span class="pre">item,</span> <span class="pre">link)</span></code>. CSD avoids this by baking the entry extractor details into the type definition, via a template argument. This is much friendlier API-wise, but requires the type to be complete.</p>
<p>If a list head must be declared before the item type is complete, it can be declared using the corresponding <code class="docutils literal notranslate"><span class="pre">fwd_head</span></code> (“forward head”) template, e.g., <code class="docutils literal notranslate"><span class="pre">slist_fwd_head</span></code>. This template only requires the <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">SizeMember</span></code> template parameters. Note that although <code class="docutils literal notranslate"><span class="pre">T</span></code> is a required parameter, it can be an incomplete.</p>
<p>To actually use the list, the proxy type <code class="docutils literal notranslate"><span class="pre">slist_proxy</span></code> is constructed, taking a reference to the <code class="docutils literal notranslate"><span class="pre">slist_fwd_head</span></code>, and imbuing it with the <code class="docutils literal notranslate"><span class="pre">EntryEx</span></code> template parameter.</p>
<p>The following example illustrates this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ListItem</span><span class="p">;</span><span class="w"> </span><span class="c1">// Note: not complete yet</span>

<span class="k">struct</span> <span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">stailq_fwd_head</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">allItemsFwd</span><span class="p">;</span><span class="w"> </span><span class="c1">// Collection of ListItems</span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">ListItem</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">slist_entry</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="w"> </span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Now that ListItem is a complete type, define `list_proxy_t` as an</span>
<span class="c1">// `slist_proxy` instead of `slist_head`.</span>
<span class="k">using</span><span class="w"> </span><span class="n">list_proxy_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slist_proxy</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">    </span><span class="n">stailq_fwd_head</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="c1">// Type of the fwd head</span>
<span class="w">    </span><span class="n">invocable_constant</span><span class="o">&lt;&amp;</span><span class="n">ListItem</span><span class="o">::</span><span class="n">link</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">   </span><span class="c1">// Late-specified EntryEx</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">printItems</span><span class="p">(</span><span class="n">S</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Construct a list_t proxy container, passing in the head object.</span>
<span class="w">  </span><span class="n">list_proxy_t</span><span class="w"> </span><span class="n">allItems</span><span class="p">{</span><span class="n">s</span><span class="p">.</span><span class="n">allItemsFwd</span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ListItem</span><span class="w"> </span><span class="o">&amp;</span><span class="nl">item</span> <span class="p">:</span><span class="w"> </span><span class="n">allItems</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;This is item #&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>As usual, a helper type alias makes the verbose template type easier to declare:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">list_proxy_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slist_proxy_cinvoke_t</span><span class="o">&lt;&amp;</span><span class="n">ListItem</span><span class="o">::</span><span class="n">link</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The “proxy” types are extremely cheap to construct (for stateless entry extractors, they only capture a reference to the “forward head”) and should be completely elided at higher optimization levels. They are also implicitly constructible from the corresponding <code class="docutils literal notranslate"><span class="pre">fwd_head</span></code> type, so the user can usually avoid explicitly constructing them, e.g.:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">printItems</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">list_proxy_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">allItems</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">S</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printItems</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">allItemsFwd</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK: calls the list_proxy_t converting constructor</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">fwd_head</span></code> and <code class="docutils literal notranslate"><span class="pre">proxy</span></code> classes separate the list’s <em>data storage</em> (in the <code class="docutils literal notranslate"><span class="pre">fwd_head</span></code>) from the list’s <em>behavior</em> (in the <code class="docutils literal notranslate"><span class="pre">proxy</span></code>), which allows list storage to be declared before the item type is completed <a class="footnote-reference brackets" href="#lists-proxy-implies-stateless" id="id2">3</a>. A <code class="docutils literal notranslate"><span class="pre">fwd_head</span></code> and <code class="docutils literal notranslate"><span class="pre">proxy</span></code> pair are somewhat like a <a class="reference external" href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a> and a <a class="reference external" href="https://en.cppreference.com/w/cpp/thread/unique_lock">std::unique_lock</a>: the former generally stores the state of the object, and the latter is “constructed around it,” as a means of operating on it.</p>
<p>The (somewhat awkward) need to construct a proxy object each time is roughly analogous to the (somewhat awkward) need to specify the linkage member each time in the old <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> macros. Thus, when you don’t need the flexibility of the <code class="docutils literal notranslate"><span class="pre">fwd_head</span> <span class="pre">+</span> <span class="pre">proxy</span></code> pattern, prefer the “all-in-one” alternative, e.g., <code class="docutils literal notranslate"><span class="pre">slist_head</span></code>.</p>
<p>As with the “head” versions, a helper macro is available to declare proxy types that use <code class="docutils literal notranslate"><span class="pre">offsetof</span></code>-based extractors:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ListItem</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">slist_entry</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="w"> </span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">using</span><span class="w"> </span><span class="n">mylist_proxy_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CSG_TAILQ_PROXY_OFFSET_T</span><span class="p">(</span><span class="n">ListItem</span><span class="p">,</span><span class="w"> </span><span class="n">link</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<section id="are-fwd-head-instances-movable">
<h3><a class="toc-backref" href="#id14">Are <code class="docutils literal notranslate"><span class="pre">fwd_head</span></code> instances movable?</a><a class="headerlink" href="#are-fwd-head-instances-movable" title="Permalink to this headline"></a></h3>
<p>For most CSD intrusive containers, the “forward head” types are <a class="reference external" href="https://en.cppreference.com/w/cpp/concepts/Movable">moveable</a>, to permit code like this: <a class="footnote-reference brackets" href="#lists-careful-moving" id="id3">2</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ListItem</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">T</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">T</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"> </span><span class="c1">// OK, `fwdItems` is movable</span>

<span class="w">  </span><span class="n">slist_fwd_head</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fwdItems</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Unfortunately this cannot work for certain data structures, namely <code class="docutils literal notranslate"><span class="pre">tailq_fwd_head</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ListItem</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">T</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">T</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"> </span><span class="c1">// Error: tailq_fwd_head&#39;s move constructor is deleted</span>

<span class="w">  </span><span class="n">tailq_fwd_head</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fwdItems</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>This is a consequence of a <a class="reference internal" href="lists-implementation.html#lists-tailq-circular-design"><span class="std std-ref">tailq implementation detail</span></a>, namely that tailq’s are circular lists with the <code class="docutils literal notranslate"><span class="pre">end()</span></code> sentinel connecting the head to the tail.</p>
<p>Because the head and tail list items must point to the address of the <code class="docutils literal notranslate"><span class="pre">tailq_fwd_head</span></code> instance (which plays the same role as <code class="docutils literal notranslate"><span class="pre">tailq_head</span></code> in <a class="reference internal" href="lists-implementation.html#lists-tailq-invocable-figure"><span class="std std-ref">this diagram</span></a>), the move logic needs to access the <code class="docutils literal notranslate"><span class="pre">EntryEx</span></code> extractor so it can edit the head and tail entries, namely to rewrite their linkage into the sentinel node. In short, a <code class="docutils literal notranslate"><span class="pre">tailq_fwd_head</span></code> by itself lacks the information needed to move the list; we must construct proxies to help move it.</p>
<p>To work around this limitation, the user must define a custom move constructor:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ListItem</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">T</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">T</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">tailq_fwd_head</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fwdItems</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">ListItem</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">tailq_entry</span><span class="w"> </span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">using</span><span class="w"> </span><span class="n">list_proxy_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tailq_proxy</span><span class="o">&lt;</span><span class="n">tailq_fwd_head</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">tailq_entry_offset</span><span class="o">&lt;</span><span class="n">offsetof</span><span class="p">(</span><span class="n">ListItem</span><span class="p">,</span><span class="w"> </span><span class="n">link</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>

<span class="n">T</span><span class="o">::</span><span class="n">T</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">list_proxy_t</span><span class="w"> </span><span class="n">ourItems</span><span class="p">{</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">fwdItems</span><span class="p">,</span><span class="w"> </span><span class="n">list_proxy_t</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">fwdItems</span><span class="p">}};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">S</span><span class="w"> </span><span class="n">s</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{.</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="p">{.</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">}</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">t1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Construct a tailq container proxy so we can insert items into t1&#39;s list.</span>
<span class="w">  </span><span class="n">list_proxy_t</span><span class="w"> </span><span class="n">items1</span><span class="p">{</span><span class="n">t1</span><span class="p">.</span><span class="n">fwdItems</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]}};</span><span class="w"></span>

<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">t2</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t1</span><span class="p">)};</span><span class="w"> </span><span class="c1">// Invoke our custom move logic</span>

<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size</span><span class="p">(</span><span class="n">items1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">size</span><span class="p">(</span><span class="n">list_t</span><span class="p">{</span><span class="n">t2</span><span class="p">.</span><span class="n">fwdItems</span><span class="p">})</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="understand-the-csd-list-concepts">
<h2><a class="toc-backref" href="#id15">Understand the CSD list concepts</a><a class="headerlink" href="#understand-the-csd-list-concepts" title="Permalink to this headline"></a></h2>
<p>Most of the implementation of an slist is contained in the class template <code class="docutils literal notranslate"><span class="pre">slist_base</span></code>. Both <code class="docutils literal notranslate"><span class="pre">slist_head</span></code> and <code class="docutils literal notranslate"><span class="pre">slist_proxy</span></code> inherit the core slist API from this base class using the <a class="reference external" href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a>. The only difference between <code class="docutils literal notranslate"><span class="pre">slist_head</span></code> and <code class="docutils literal notranslate"><span class="pre">slist_proxy</span></code> is that the former is more “elegant,” at the expense of requiring complete types.</p>
<p>A function taking any kind of slist can be defined like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">csg</span><span class="o">::</span><span class="n">slist</span><span class="w"> </span><span class="n">ListType</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">ListType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">anySList</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The single-argument concepts <code class="docutils literal notranslate"><span class="pre">tailq</span></code>, <code class="docutils literal notranslate"><span class="pre">stailq</span></code>, and <code class="docutils literal notranslate"><span class="pre">slist</span></code> evaluate to true if the given type argument is a CSD list of the appropriate kind. The concept <code class="docutils literal notranslate"><span class="pre">singly_linked_list</span></code> can be used to check for either <code class="docutils literal notranslate"><span class="pre">stailq</span></code> or <code class="docutils literal notranslate"><span class="pre">slist</span></code>, which have similar APIs because they are both singly-linked lists. All CSD lists satisfy the <code class="docutils literal notranslate"><span class="pre">linked_list</span></code> concept.</p>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="lists-complete-type"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>As explained in <a class="reference internal" href="intrusive-extractors.html"><span class="doc">Extractors: the Core Intrusive Concept</span></a>, <code class="docutils literal notranslate"><span class="pre">&amp;ListItem::link</span></code> may also appear inside the body of <code class="docutils literal notranslate"><span class="pre">ListItem</span></code> while it is still being defined, as long as the field declaration has already occurred.</p>
</dd>
<dt class="label" id="lists-careful-moving"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>The user must be careful when using movable <code class="docutils literal notranslate"><span class="pre">fwd_head</span></code> instances. Any <cite>proxy`</cite> instances still attached to the forward head will now affect the moved-from head. The effects of doing this are undefined.</p>
</dd>
<dt class="label" id="lists-proxy-implies-stateless"><span class="brackets"><a class="fn-backref" href="#id2">3</a></span></dt>
<dd><p>In <a class="reference internal" href="#lists-how-to-choose-extractor"><span class="std std-ref">Choosing the EntryEx parameter</span></a> we note that the user is free to use a stateful entry extractor. These can be difficult to work with when using the <code class="docutils literal notranslate"><span class="pre">fwd_head</span> <span class="pre">+</span> <span class="pre">proxy</span></code> pattern, because the extractor state must be passed to each <code class="docutils literal notranslate"><span class="pre">proxy</span></code> instance (<code class="docutils literal notranslate"><span class="pre">proxy</span></code> instances are ephemeral wrapper types with short life-spans). For entry extractors which contain move-only types (e.g., a <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>) it should still be possible, but may not be worth the effort.</p>
</dd>
</dl>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lists-main.html" class="btn btn-neutral float-left" title="Lists Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lists-rationale.html" class="btn btn-neutral float-right" title="Why Intrusive Lists?" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Kenneth Camann.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>