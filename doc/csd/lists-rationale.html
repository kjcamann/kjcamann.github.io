<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Why Intrusive Lists? &mdash; CSD 2021.1-alpha documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="How CSD merges the queue(3) and STL container designs" href="lists-queue-and-stl.html" />
    <link rel="prev" title="Lists Quick Start Guide" href="lists-guide.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CSD
            <img src="_static/csd-logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2021.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="intrusive-main.html">Intrusive Container Utilities</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="lists-main.html">Lists Library</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lists-guide.html">Lists Quick Start Guide</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Why Intrusive Lists?</a></li>
<li class="toctree-l2"><a class="reference internal" href="lists-queue-and-stl.html">How CSD merges the <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> and STL container designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="lists-reference.html">Lists Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="lists-implementation.html">CSD lists implementation notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utility-main.html">Utility Libraries</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CSD</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="lists-main.html">Lists Library</a> &raquo;</li>
      <li>Why Intrusive Lists?</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/lists-rationale.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="why-intrusive-lists">
<h1>Why Intrusive Lists?<a class="headerlink" href="#why-intrusive-lists" title="Permalink to this headline"></a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#linked-lists-aren-t-those-maddeningly-slow-data-structures" id="id2">Linked lists? Aren’t those maddeningly slow data structures?</a></p></li>
<li><p><a class="reference internal" href="#what-makes-code-good" id="id3">What makes code “good”?</a></p></li>
<li><p><a class="reference internal" href="#how-do-data-structures-affect-code-quality" id="id4">How do data structures affect code quality?</a></p></li>
<li><p><a class="reference internal" href="#an-example-the-freebsd-process-tree" id="id5">An example: the FreeBSD process tree</a></p></li>
<li><p><a class="reference internal" href="#why-does-it-work" id="id6">Why does it work?</a></p></li>
</ul>
</div>
<section id="linked-lists-aren-t-those-maddeningly-slow-data-structures">
<h2><a class="toc-backref" href="#id2">Linked lists? Aren’t those maddeningly slow data structures?</a><a class="headerlink" href="#linked-lists-aren-t-those-maddeningly-slow-data-structures" title="Permalink to this headline"></a></h2>
<p>You can find many blogs showing that <code class="docutils literal notranslate"><span class="pre">std::list</span></code> performance is terrible compared to more popular choices. Even worse, Bjarne himself says that the “default advice is to <a class="reference external" href="http://www.stroustrup.com/bs_faq.html#list">prefer to std::vector</a>.” What hope is there for lists, let alone intrusive lists? Do they have any place in the modern programming world, aside from “white board” parlor tricks during your job interview at the local spaghetti-code factory?</p>
<p>If you’ve mentally written off lists, at least ponder the following:</p>
<blockquote>
<div><p>If intrusive lists are so bad, why do they appear everywhere in operating system kernels, which are some of the best-engineered pieces of software in existence?</p>
</div></blockquote>
<p>I’ve heard many people who don’t know the answer try to guess at it. “The code base is so old,” they say, “it probably predates the <a class="reference external" href="https://en.wikipedia.org/wiki/Random-access_memory#Memory_wall">memory wall</a>! If they rewrote it today, the whole thing would be vectors!”</p>
<p>No, it would not.</p>
<p>The real answer is deeper than you might think – so deep that it goes right to the heart of the dysfunction in modern computer programming.</p>
</section>
<section id="what-makes-code-good">
<h2><a class="toc-backref" href="#id3">What makes code “good”?</a><a class="headerlink" href="#what-makes-code-good" title="Permalink to this headline"></a></h2>
<blockquote class="epigraph">
<div><p>The art of programming is the art of organizing complexity, of mastering multitude and avoiding its bastard chaos as effectively as possible.
– Edsger Dijkstra</p>
</div></blockquote>
<div class="compound">
<p class="compound-first">How many spaces do you indent? Four seems to be a popular choice these days, but my own style was influenced by <a class="reference external" href="https://llvm.org">LLVM</a> – the first well-written C++ program I stumbled across – which uses only two. Although I have to admit, there isn’t much of a difference between this:</p>
<div class="compound-middle highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Wrong number of arguments!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">start</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="compound-middle">and this:</p>
<div class="compound-middle highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Wrong number of arguments!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">start</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="compound-middle">but I suspect this will make you uncomfortable:</p>
<div class="compound-middle highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Wrong number of arguments!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">start</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p class="compound-middle">and this <em>definitely</em> will:</p>
<div class="compound-last highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Wrong number of arguments!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="n">start</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>As all programmers know, indentation is critical to how we understand program structure, especially flow control. Most of us take it for granted that some attention to formatting is important, but there is a surprising lesson when we start to ask <em>why</em>.</p>
<p>Computers obviously do not need indentation – it gets compiled away. The purpose of those compilers is to translate a program between two languages that have vastly different properties. The source language is full of human-sensitive cues that make comprehension easy. For example, any graphic designer will tell you that people are very sensitive to <em>alignment cues</em>, so language designers exploit vertical alignment (“indentation”) to convey “grouping” concepts. These choices are entirely motivated by patterns in human cognition; it has nothing to do with computers.</p>
<p>Source languages have a downside of course: it is difficult to design a machine that directly executes their code. Thus a “target language” (e.g., a CPU  <a class="reference external" href="https://en.wikipedia.org/wiki/Instruction_set_architecture">ISA</a>) is designed to be “friendly” to a computation machine. Such languages are so explicit and tedious that it’s a cakewalk to design a machine for them, but they can only be understood by a human at tremendous mental cost. The role of compilers is the automatic translation of the same program between two such languages.</p>
<p>Thus, quality <em>source</em> code is primarily about <em>understanding how to make ideas clear and obvious to a human</em>. This isn’t just an “important dimension” of code quality, <strong>it is literally the only reason why we use programming languages at all</strong>. Yet sadly, most programmers are bad at it – their own code makes sense <em>to them</em> (at least for the moment) so why waste time trying to be clear?</p>
</section>
<section id="how-do-data-structures-affect-code-quality">
<h2><a class="toc-backref" href="#id4">How do data structures affect code quality?</a><a class="headerlink" href="#how-do-data-structures-affect-code-quality" title="Permalink to this headline"></a></h2>
<p>There is tremendous focus in computer science education on technical matters, while almost no attention is paid to how programmers can make code more <em>comprehensible</em>. This isn’t surprising – the knowledge for what a garden-variety human finds clear or obvious tends to live outside the computer science department. In most cases, a psychology professor could tell you far more about the subject than a computer scientist.</p>
<p>Thus you might hear someone say “this data structure is great because it has <span class="math notranslate nohighlight">\(O(1)\)</span> insertion performance!” but you’ll never hear “this data structure is great because helps our program <em>make sense</em>.” It’s so rare to hear something like that, that you might even wonder how data structure choice can affect comprehension. After all, <a class="reference external" href="https://en.wikipedia.org/wiki/Alexander_Stepanov">Alexander Stepanov</a> largely succeeded at designing completely generic interfaces for containers, so you might think any ugly implementation details can hide safely behind those interfaces.</p>
<p>Consider, for example, a C++ <code class="docutils literal notranslate"><span class="pre">std::unordered_map</span></code> vs. a <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>. What is the salient difference between the two? If you said something about the “big O” of various operations, this is technically true, but misses the point.</p>
<p>One critical difference is pointer stability or, in C++ parlance, when pointers to contained elements are invalidated (<code class="docutils literal notranslate"><span class="pre">std::unordered-map</span></code> almost never invalidates a reference to a contained element). The complexity of large software systems is primarily about the complexity of relationships between its many parts. If you can safely capture a pointer or reference to an object because you know it won’t disappear, you can write code that looks like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Child</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Parent</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>It is impossible to look at this code and not understand what <code class="docutils literal notranslate"><span class="pre">p</span></code> is – it’s the child instance’s parent!</p>
<p>But if you don’t have pointer stability then you <em>can’t</em> do this. You need to store a key or index and perform a lookup, and the code ends up looking a little more obscure:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Child</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">parentIdx</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Parent</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">parents</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">Parent</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">getParent</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">parents</span><span class="p">)[</span><span class="n">parentIdx</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Notice what has happened here. Yes, we are using a vector and we may be rewarded with better performance in other parts of the system (e.g., algorithms that visit all <code class="docutils literal notranslate"><span class="pre">Child</span></code> elements). But the <em>program structure</em> has also changed. Our data is organized in a different way. It doesn’t <em>look</em> the same, and it’s slighty harder to “see” what’s going on. Of course it doesn’t matter much: this example is small and more importantly, there is only one relationship (a simple parent/child relationship). But as the number of relationships grows, the “comprehension cost” of the latter approach will grow enormously.</p>
<p>The real power of the intrusive list is that it makes code look more like the first example. As we’ll demonstrate with a real example in the next section, the fact that the links are intrusive has a profound impact on how the code is organized and especially on how you read it. All of this makes almost no difference on a technical level. Yes the cache locality can be worse than <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>. Outside of micro-benchmarks, the negative cache effects are usually unimportant.</p>
</section>
<section id="an-example-the-freebsd-process-tree">
<h2><a class="toc-backref" href="#id5">An example: the FreeBSD process tree</a><a class="headerlink" href="#an-example-the-freebsd-process-tree" title="Permalink to this headline"></a></h2>
<p>UNIX processes have a very complex set of relationships among themselves. A process has:</p>
<ul class="simple">
<li><p>An entry in the process table (the global list of all processes)</p></li>
<li><p>A parent process</p></li>
<li><p>An entry in a process group</p></li>
<li><p>A numeric pid, which can be used to look up the process via a hash table</p></li>
<li><p>A list of siblings in the process tree (processes having the same parent)</p></li>
<li><p>A list of child processes</p></li>
<li><p>A reaper process, the ancestor that will adopt the process if it becomes a zombie</p></li>
<li><p>A “reap-list” of associated zombies if the process is acting as a reaper for its sub-tree</p></li>
</ul>
<p>The figure below, taken from <a class="reference external" href="https://books.google.com/books?isbn=0321968972">The Design and Implementation of the FreeBSD Operating System</a>, depicts some of the relationship between processes:</p>
<figure class="align-default" id="id1">
<span id="lists-freebsd-proc-relationships"></span><img alt="Relationships between processes in the UNIX model" src="_images/design-impl-freebsd-proc.png" />
<figcaption>
<p><span class="caption-text">An illustration of some of the relationships between processes, appearing in the “Process Management” chapter of <em>The Design and Implementation of the FreeBSD Operating System</em>.</span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>If you think it would easy to forget what all these relationships are while looking at the FreeBSD source code…you would actually be wrong.</p>
<p>Look at the definition of the FreeBSD process structure (from <code class="docutils literal notranslate"><span class="pre">&lt;sys/proc.h&gt;</span></code>) and pay attention to the highlighted lines:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cm">/*</span>
<span class="linenos"> 2</span><span class="cm"> * Process structure.</span>
<span class="linenos"> 3</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos"> 4</span><span class="k">struct</span> <span class="nc">proc</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="hll"><span class="linenos"> 5</span><span class="w">        </span><span class="n">LIST_ENTRY</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span><span class="w"> </span><span class="n">p_list</span><span class="p">;</span><span class="w">     </span><span class="cm">/* (d) List of all processes. */</span><span class="w"></span>
</span><span class="linenos"> 6</span><span class="w">        </span><span class="n">TAILQ_HEAD</span><span class="p">(,</span><span class="w"> </span><span class="kr">thread</span><span class="p">)</span><span class="w"> </span><span class="n">p_threads</span><span class="p">;</span><span class="w">      </span><span class="cm">/* (c) all threads. */</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">        </span><span class="k">struct</span> <span class="nc">mtx</span><span class="w">   </span><span class="n">p_slock</span><span class="p">;</span><span class="w">        </span><span class="cm">/* process spin lock */</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">        </span><span class="k">struct</span> <span class="nc">ucred</span><span class="w"> </span><span class="o">*</span><span class="n">p_ucred</span><span class="p">;</span><span class="w">       </span><span class="cm">/* (c) Process owner&#39;s identity. */</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">        </span><span class="k">struct</span> <span class="nc">filedesc</span><span class="w">      </span><span class="o">*</span><span class="n">p_fd</span><span class="p">;</span><span class="w">          </span><span class="cm">/* (b) Open files. */</span><span class="w"></span>
<span class="linenos">10</span><span class="w">        </span><span class="k">struct</span> <span class="nc">filedesc_to_leader</span><span class="w"> </span><span class="o">*</span><span class="n">p_fdtol</span><span class="p">;</span><span class="w"> </span><span class="cm">/* (b) Tracking node */</span><span class="w"></span>
<span class="linenos">11</span><span class="w">        </span><span class="k">struct</span> <span class="nc">pstats</span><span class="w">        </span><span class="o">*</span><span class="n">p_stats</span><span class="p">;</span><span class="w">       </span><span class="cm">/* (b) Accounting/statistics (CPU). */</span><span class="w"></span>
<span class="linenos">12</span><span class="w">        </span><span class="k">struct</span> <span class="nc">plimit</span><span class="w">        </span><span class="o">*</span><span class="n">p_limit</span><span class="p">;</span><span class="w">       </span><span class="cm">/* (c) Resource limits. */</span><span class="w"></span>
<span class="linenos">13</span><span class="w">        </span><span class="k">struct</span> <span class="nc">callout</span><span class="w">       </span><span class="n">p_limco</span><span class="p">;</span><span class="w">        </span><span class="cm">/* (c) Limit callout handle */</span><span class="w"></span>
<span class="linenos">14</span><span class="w">        </span><span class="k">struct</span> <span class="nc">sigacts</span><span class="w">       </span><span class="o">*</span><span class="n">p_sigacts</span><span class="p">;</span><span class="w">     </span><span class="cm">/* (x) Signal actions, state (CPU). */</span><span class="w"></span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">        </span><span class="kt">int</span><span class="w">          </span><span class="n">p_flag</span><span class="p">;</span><span class="w">         </span><span class="cm">/* (c) P_* flags. */</span><span class="w"></span>
<span class="linenos">17</span><span class="w">        </span><span class="kt">int</span><span class="w">          </span><span class="n">p_flag2</span><span class="p">;</span><span class="w">        </span><span class="cm">/* (c) P2_* flags. */</span><span class="w"></span>
<span class="linenos">18</span><span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">19</span><span class="w">                </span><span class="n">PRS_NEW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">         </span><span class="cm">/* In creation */</span><span class="w"></span>
<span class="linenos">20</span><span class="w">                </span><span class="n">PRS_NORMAL</span><span class="p">,</span><span class="w">          </span><span class="cm">/* threads can be run. */</span><span class="w"></span>
<span class="linenos">21</span><span class="w">                </span><span class="n">PRS_ZOMBIE</span><span class="w"></span>
<span class="linenos">22</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">p_state</span><span class="p">;</span><span class="w">                   </span><span class="cm">/* (j/c) Process status. */</span><span class="w"></span>
<span class="linenos">23</span><span class="w">        </span><span class="kt">pid_t</span><span class="w">                </span><span class="n">p_pid</span><span class="p">;</span><span class="w">          </span><span class="cm">/* (b) Process identifier. */</span><span class="w"></span>
<span class="hll"><span class="linenos">24</span><span class="w">        </span><span class="n">LIST_ENTRY</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span><span class="w"> </span><span class="n">p_hash</span><span class="p">;</span><span class="w">     </span><span class="cm">/* (d) Hash chain. */</span><span class="w"></span>
</span><span class="hll"><span class="linenos">25</span><span class="w">        </span><span class="n">LIST_ENTRY</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span><span class="w"> </span><span class="n">p_pglist</span><span class="p">;</span><span class="w">   </span><span class="cm">/* (g + e) List of processes in pgrp. */</span><span class="w"></span>
</span><span class="hll"><span class="linenos">26</span><span class="w">        </span><span class="k">struct</span> <span class="nc">proc</span><span class="w">  </span><span class="o">*</span><span class="n">p_pptr</span><span class="p">;</span><span class="w">        </span><span class="cm">/* (c + e) Pointer to parent process. */</span><span class="w"></span>
</span><span class="hll"><span class="linenos">27</span><span class="w">        </span><span class="n">LIST_ENTRY</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span><span class="w"> </span><span class="n">p_sibling</span><span class="p">;</span><span class="w">  </span><span class="cm">/* (e) List of sibling processes. */</span><span class="w"></span>
</span><span class="hll"><span class="linenos">28</span><span class="w">        </span><span class="n">LIST_HEAD</span><span class="p">(,</span><span class="w"> </span><span class="n">proc</span><span class="p">)</span><span class="w"> </span><span class="n">p_children</span><span class="p">;</span><span class="w">        </span><span class="cm">/* (e) Pointer to list of children. */</span><span class="w"></span>
</span><span class="hll"><span class="linenos">29</span><span class="w">        </span><span class="k">struct</span> <span class="nc">proc</span><span class="w">  </span><span class="o">*</span><span class="n">p_reaper</span><span class="p">;</span><span class="w">      </span><span class="cm">/* (e) My reaper. */</span><span class="w"></span>
</span><span class="hll"><span class="linenos">30</span><span class="w">        </span><span class="n">LIST_HEAD</span><span class="p">(,</span><span class="w"> </span><span class="n">proc</span><span class="p">)</span><span class="w"> </span><span class="n">p_reaplist</span><span class="p">;</span><span class="w">        </span><span class="cm">/* (e) List of my descendants</span>
</span><span class="linenos">31</span><span class="cm">                                               (if I am reaper). */</span><span class="w"></span>
<span class="hll"><span class="linenos">32</span><span class="w">        </span><span class="n">LIST_ENTRY</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span><span class="w"> </span><span class="n">p_reapsibling</span><span class="p">;</span><span class="w">      </span><span class="cm">/* (e) List of siblings - descendants of</span>
</span><span class="linenos">33</span><span class="cm">                                               the same reaper. */</span><span class="w"></span>
<span class="linenos">34</span><span class="w">        </span><span class="k">struct</span> <span class="nc">mtx</span><span class="w">   </span><span class="n">p_mtx</span><span class="p">;</span><span class="w">          </span><span class="cm">/* (n) Lock for this struct. */</span><span class="w"></span>
<span class="linenos">35</span><span class="w">        </span><span class="k">struct</span> <span class="nc">mtx</span><span class="w">   </span><span class="n">p_statmtx</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Lock for the stats */</span><span class="w"></span>
<span class="linenos">36</span><span class="w">        </span><span class="k">struct</span> <span class="nc">mtx</span><span class="w">   </span><span class="n">p_itimmtx</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Lock for the virt/prof timers */</span><span class="w"></span>
<span class="linenos">37</span><span class="w">        </span><span class="k">struct</span> <span class="nc">mtx</span><span class="w">   </span><span class="n">p_profmtx</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Lock for the profiling */</span><span class="w"></span>
<span class="linenos">38</span>
<span class="linenos">39</span><span class="w">        </span><span class="cm">/* ...many fields removed from CSD documentation... */</span><span class="w"></span>
<span class="linenos">40</span>
<span class="linenos">41</span><span class="w">        </span><span class="cm">/*</span>
<span class="linenos">42</span><span class="cm">         * An orphan is the child that has beed re-parented to the</span>
<span class="linenos">43</span><span class="cm">         * debugger as a result of attaching to it.  Need to keep</span>
<span class="linenos">44</span><span class="cm">         * track of them for parent to be able to collect the exit</span>
<span class="linenos">45</span><span class="cm">         * status of what used to be children.</span>
<span class="linenos">46</span><span class="cm">         */</span><span class="w"></span>
<span class="hll"><span class="linenos">47</span><span class="w">        </span><span class="n">LIST_ENTRY</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span><span class="w"> </span><span class="n">p_orphan</span><span class="p">;</span><span class="w">   </span><span class="cm">/* (e) List of orphan processes. */</span><span class="w"></span>
</span><span class="hll"><span class="linenos">48</span><span class="w">        </span><span class="n">LIST_HEAD</span><span class="p">(,</span><span class="w"> </span><span class="n">proc</span><span class="p">)</span><span class="w"> </span><span class="n">p_orphans</span><span class="p">;</span><span class="w"> </span><span class="cm">/* (e) Pointer to list of orphans. */</span><span class="w"></span>
</span><span class="linenos">49</span><span class="w">        </span><span class="n">u_int</span><span class="w">                </span><span class="n">p_ptevents</span><span class="p">;</span><span class="w">     </span><span class="cm">/* (c) ptrace() event mask. */</span><span class="w"></span>
<span class="linenos">50</span><span class="w">        </span><span class="kt">uint16_t</span><span class="w">     </span><span class="n">p_elf_machine</span><span class="p">;</span><span class="w">  </span><span class="cm">/* (x) ELF machine type */</span><span class="w"></span>
<span class="linenos">51</span><span class="w">        </span><span class="kt">uint64_t</span><span class="w">     </span><span class="n">p_elf_flags</span><span class="p">;</span><span class="w">    </span><span class="cm">/* (x) ELF flags */</span><span class="w"></span>
<span class="linenos">52</span><span class="w">        </span><span class="n">sigqueue_t</span><span class="w">   </span><span class="n">p_sigqueue</span><span class="p">;</span><span class="w">     </span><span class="cm">/* (c) Sigs not delivered to a td. */</span><span class="w"></span>
<span class="linenos">53</span><span class="cp">#define p_siglist    p_sigqueue.sq_signals</span>
<span class="linenos">54</span><span class="w">        </span><span class="kt">int</span><span class="w">          </span><span class="n">p_pdeathsig</span><span class="p">;</span><span class="w">    </span><span class="cm">/* (c) Signal from parent on exit. */</span><span class="w"></span>
<span class="linenos">55</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The highlighted lines show either direct pointers (e.g., to the parent process and reaper), <a class="reference external" href="https://man.openbsd.org/queue.3">queue(3)</a> intrusive links that make the process an entry on some list, or <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> heads that start a new list specific to this process (e.g., the list of our children). If you stare at the definition of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">proc</span></code> long enough to get over how ugly the <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> macros are, you’ll notice something:</p>
<p><strong>You cannot even look at the definition of what a process is without immediately seeing all the data structures it lives in, and what the nature of the relationships are.</strong></p>
<p>For example, a process can <em>be</em> an orphan (it has linkage into the global list of orphans on line 47) and it can act as the <em>adopted parent</em> of orphans (typically only <code class="docutils literal notranslate"><span class="pre">init</span></code> does this), using the list head on line 48. Orphans and zombies are a rather esoteric bit of UNIX architecture, and you will probably forget them. But seeing the definition of <code class="docutils literal notranslate"><span class="pre">&lt;sys/proc.h&gt;</span></code> is enough to immediately remember it. Moreover, you can’t <em>help</em> but see it, every time you look at the definition of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">proc</span></code> – which is often! Before you know it, you’ve learned a critical aspect of the OS design <em>and</em> the code which implements it!</p>
<p>Neatly collecting all this information in one well-defined, easy-to-remember place is a comprehension super-power. Not only that, but it is further enhanced by the style of the FreeBSD architectural documentation: there is typically an intimate relationship between the diagrams in the book, and the structure of the code.</p>
<p>Look again at the <a class="reference internal" href="#lists-freebsd-proc-relationships"><span class="std std-ref">process diagram above</span></a>. Like so many “enterprise architect” diagrams, this picture may appear to be an abstract block diagram which only hints at the relationships between processes – but it is not. The elegant simplicity of the intrusive lists means that the arrows do not represent some abstract (i.e., hard-to-understand) “relationship.” The boxes are instances of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">proc</span></code> and the arrows are literally just the linkage pointers in the intrusive lists. The diagram doesn’t “suggest” how the data is organized – it is more like a concrete representation of the in-memory objects.</p>
<p>If you study FreeBSD, you tend to have the following experience: first you read a chapter in the book that explains a high-level concept. Despite being conceptual (there is almost no source code in the book), the relationships between concepts are usually illustrated in a diagram like the one above. Then you pick up the source code. It is usually trivial to discover how the concept is modeled in the code, because despite being written in C, UNIX is a marvel of “object oriented” design: every <em>concept</em> gets a <em>language-level object</em> (usually a <code class="docutils literal notranslate"><span class="pre">struct</span></code>) that explicitly models it,  with the same name. It is also trivial to discover how it relates to all the other concepts: there are usually <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> entries to all the structures modeling the related concepts, exactly as they appear in the diagram. You are rarely at a loss to understand where something is defined. Even if all you have is <code class="docutils literal notranslate"><span class="pre">grep</span></code>, knowing the name of the <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> entry member is usually enough to find all users/modifiers of the relationship.</p>
</section>
<section id="why-does-it-work">
<h2><a class="toc-backref" href="#id6">Why does it work?</a><a class="headerlink" href="#why-does-it-work" title="Permalink to this headline"></a></h2>
<p>Many of us in the C++ developer community know Sean Parent; he has given a number of well-received talks at various C++ conferences. One theme in his talks is that it is critical to be able to “locally reason about code.” The big question is: do I have to look at <em>one place</em> in the code to understand what’s going on, or do I have to look <em>everywhere</em>. The cost of just <em>finding</em> all the places you’re supposed to look will increase as program size increases, and the comprehension cost will increase much more dramatically. In one of his most popular talks, he emphasizes using value semantics where possible – the lack of reference semantics means no other part the program (no matter how large!) can possibly affect the code we’re looking at.</p>
<p>I think he’s on to something: it seems that all the comprehension superpowers I know – indentation, value semantics, intrusive lists, etc. – ultimately derive their power from how they enrich a small piece of text with a lot of information.</p>
<p>Early in the development of CSD, intrusive entry objects did not re-specify the type of linked list they lived in, i.e., code using CSD used to look like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ListItem</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">tailq_entry</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w">  </span><span class="c1">// Note: not a template</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Later, it was changed to its current form:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ListItem</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">tailq_entry</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="o">&gt;</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="c1">// Link us into a list of other ListItems</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>This is redundant, and the template makes the implementation more complex. It was changed because after a long hiatus of not reading any FreeBSD kernel code, I returned to it and discovered that it makes some small difference – in terms of “effortless comprehension” – to see the type of the list locally restated. Look again at the above code listing for the FreeBSD process structure, <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">proc</span></code>. All the entry macros restate that their purpose is to join a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">proc</span></code> into a data structure containing other <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">proc</span></code> instances, e.g., <code class="docutils literal notranslate"><span class="pre">LIST_ENTRY(proc)</span> <span class="pre">p_list</span></code> for the global process list.</p>
<p>This is needed in <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> because of how the implementation works, but it is not strictly necessary in CSD. In the old code, that the <code class="docutils literal notranslate"><span class="pre">e</span></code> member links us into a list of other <code class="docutils literal notranslate"><span class="pre">ListItem</span></code> instances is <em>implicit</em>: we know it’s true because we’re using an intrusive list and by definition, intrusive lists link the kind of objects that contain the intrusive linkage. The old way wasn’t exactly <em>hard</em> to understand without this extra comprehension cue, but it lacked the clarity evident in the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">proc</span></code> example. This originally went unnoticed because it doesn’t make much of a difference in simple examples, like the one above. As the structures grow larger, it becomes more difficult to keep track of things that are implicit/contextual. As CSD was used more extensively, it became clear that the original <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> style was better because it improved – in the words of Sean Parent – the “ability to locally reason about code.”</p>
<p>For what it’s worth, I don’t think Sean Parent would be that enamored of intrusive lists: they are typically reference-heavy structures that point all over the place. That said, I doubt there is much of an alternative. Look at the sheer number of different data structures that a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">proc</span></code> must simultaneously live in. This number cannot be reduced; the complexity of those relationships is specified by the UNIX process model, which has served us well for decades; it’s a good design we want to keep. Our goal is to create a source code design that helps us “mentally manage” that complexity. Intrusive lists make it possible to see all these relationships together and to draw clear architecture diagrams of how they appear in code. That makes it easier for new engineers to learn that architecture and the kernel code base, ensuring that UNIX continues to march on to victory.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>At the beginning of this article, I asserted that no one uses intrusive lists because of a sickness at the heart of professional computer programming. You would be forgiven for thinking that this is a ridiculous claim, or a non-sequituer, or just plain clickbait. It is actually true in a “trivial” sense; it is just a consequence of a more important truth.</p>
<p>The explanation of what ails modern computer programming, as it turns out, isn’t so easy to summarize in a single help section, so it was moved to its own part of the manual page. <em>TODO</em>: add this article.</p>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lists-guide.html" class="btn btn-neutral float-left" title="Lists Quick Start Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lists-queue-and-stl.html" class="btn btn-neutral float-right" title="How CSD merges the queue(3) and STL container designs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Kenneth Camann.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>