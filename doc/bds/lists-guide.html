

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Lists Quick Start Guide &mdash; BDS 2018.1-alpha1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Why Intrusive Lists?" href="lists-rationale.html" />
    <link rel="prev" title="Lists Library" href="lists-main.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> BDS
          

          
            
            <img src="_static/bds-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                2018.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="lists-main.html">Lists Library</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Lists Quick Start Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="lists-rationale.html">Why Intrusive Lists?</a></li>
<li class="toctree-l2"><a class="reference internal" href="lists-queue-and-stl.html">How BDS merges the <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> and STL container designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="lists-reference.html">Lists Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="lists-implementation.html">BDS lists implementation notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utilities-main.html">Utility Libraries</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BDS</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="lists-main.html">Lists Library</a> &raquo;</li>
        
      <li>Lists Quick Start Guide</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/lists-guide.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="lists-quick-start-guide">
<h1>Lists Quick Start Guide<a class="headerlink" href="#lists-quick-start-guide" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#what-are-bds-lists" id="id3">What are BDS lists?</a></li>
<li><a class="reference internal" href="#a-simple-example" id="id4">A simple example</a></li>
<li><a class="reference internal" href="#where-do-i-find-the-api-documentation" id="id5">Where do I find the API documentation?</a></li>
<li><a class="reference internal" href="#choosing-the-template-parameters" id="id6">Choosing the template parameters</a><ul>
<li><a class="reference internal" href="#choosing-the-entryaccess-parameter" id="id7">Choosing the EntryAccess parameter</a><ul>
<li><a class="reference internal" href="#the-member-offset-functor" id="id8">The member offset functor</a></li>
<li><a class="reference internal" href="#the-invocable-member-access-functor" id="id9">The invocable/member-access functor</a></li>
<li><a class="reference internal" href="#when-to-use-offset-based-vs-invocable-accessors" id="id10">When to use offset-based vs. invocable accessors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#choosing-the-sizetype-parameter" id="id11">Choosing the SizeType Parameter</a></li>
</ul>
</li>
<li><a class="reference internal" href="#understanding-the-head-vs-fwd-head-container-templates" id="id12">Understanding the <code class="docutils literal notranslate"><span class="pre">head</span></code> vs <code class="docutils literal notranslate"><span class="pre">fwd_head</span> <span class="pre">+</span> <span class="pre">container</span></code> templates</a></li>
<li><a class="reference internal" href="#understand-the-bds-list-concepts" id="id13">Understand the BDS list concepts</a></li>
</ul>
</div>
<div class="section" id="what-are-bds-lists">
<h2><a class="toc-backref" href="#id3">What are BDS lists?</a><a class="headerlink" href="#what-are-bds-lists" title="Permalink to this headline">¶</a></h2>
<p>BDS lists are intrusive linked lists based on the <a class="reference external" href="https://man.openbsd.org/queue.3">BSD queue(3) library</a>. That library first appeared in 4.4 BSD, and is available today on most UNIX systems via the header file <code class="docutils literal notranslate"><span class="pre">&lt;sys/queue.h&gt;</span></code> (it is also included in glibc and can be found on most Linux systems). Linked lists are used to implement queues in various UNIX kernels, thus the name “queue.”</p>
<p>The original queue library has been copied into or reimplemented in many well-known C code bases, including the Linux kernel. Like most data structure libraries written in C, it relies on macros to achieve static polymorphism. BDS lists are C++20 re-implementations that combine the data structure design from BSD queues with the design of STL containers. For example, it achieves static polymorphism using templates instead of macros.</p>
<p>To read more on why intrusive linked lists are a great data structure, see <a class="reference internal" href="lists-rationale.html"><span class="doc">Why Intrusive Lists?</span></a></p>
<p>BDS provides the four data structures from <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code>:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">slist:</th><td class="field-body"><p class="first">Singly-linked lists</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">stailq:</th><td class="field-body"><p class="first">Singly-linked tail queues; a “tail queue” is a list that keeps track of the last element, which allows fast insertion at the end of the list and fast list concatenation</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">tailq:</th><td class="field-body"><p class="first">Doubly-linked tail queues, i.e., doubly-linked lists that also have the tail queue features</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">list:</th><td class="field-body"><div class="first admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">list is deprecated and should be avoided.</p>
</div>
<p class="last">In the original <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> library, there is a difference between a <code class="docutils literal notranslate"><span class="pre">LIST</span></code> and a <code class="docutils literal notranslate"><span class="pre">TAILQ</span></code>, but in BDS there is not. To meet the design goal of being STL-friendly, the C++ implementation of lists and tailqs must be exactly the same (see <a class="reference internal" href="lists-queue-and-stl.html#lists-diff-with-queue"><span class="std std-ref">here</span></a> for a detailed explanation). If <code class="docutils literal notranslate"><span class="pre">&lt;bds/list.h&gt;</span></code> is included, it makes lists available through tailq type aliases, but adds deprecation attributes.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="a-simple-example">
<h2><a class="toc-backref" href="#id4">A simple example</a><a class="headerlink" href="#a-simple-example" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++ notranslate" id="lists-main-example"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bds/slist.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">ListItem</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>                 <span class="c1">// List item&#39;s data</span>
  <span class="n">bds</span><span class="o">::</span><span class="n">slist_entry</span> <span class="n">link</span><span class="p">;</span> <span class="c1">// Intrusive link that makes us part of a list</span>
<span class="p">};</span>

<span class="c1">// The head of the list is a class template. The second template</span>
<span class="c1">// parameter is a functor that controls how the list locates the</span>
<span class="c1">// intrusive links inside the list items (in this case, via a member</span>
<span class="c1">// offset calculation).</span>
<span class="k">using</span> <span class="n">list_t</span> <span class="o">=</span>
    <span class="n">bds</span><span class="o">::</span><span class="n">slist_head</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="p">,</span> <span class="n">slist_entry_offset</span><span class="o">&lt;</span><span class="n">offsetof</span><span class="p">(</span><span class="n">ListItem</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Create an empty list and two items, then add the items to the list.</span>
<span class="n">list_t</span> <span class="n">L</span><span class="p">;</span>
<span class="n">ListItem</span> <span class="n">item1</span><span class="p">{.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">},</span> <span class="n">item2</span><span class="p">{.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">};</span>

<span class="n">L</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item2</span><span class="p">);</span> <span class="c1">// Note: insertion by pointer. This is explained</span>
<span class="n">L</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item1</span><span class="p">);</span> <span class="c1">// in the next section of this guide.</span>

<span class="c1">// Print the items.</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">ListItem</span> <span class="o">&amp;</span><span class="nl">item</span> <span class="p">:</span> <span class="n">L</span><span class="p">)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;This is item #&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>This will print</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This is item #1
This is item #2
</pre></div>
</div>
</div>
<div class="section" id="where-do-i-find-the-api-documentation">
<span id="lists-where-are-the-docs"></span><h2><a class="toc-backref" href="#id5">Where do I find the API documentation?</a><a class="headerlink" href="#where-do-i-find-the-api-documentation" title="Permalink to this headline">¶</a></h2>
<p>There is deliberately very little doxygen documentation for BDS list member functions. They are meant to follow the standard C++ list APIs as much as possible, so you should use your favorite C++ reference (e.g., <a class="reference external" href="https://cppreference.com">cppreference</a>) for <a class="reference external" href="https://cppreference.com/w/cpp/container/list">&lt;list&gt;</a> when referencing tailq and <a class="reference external" href="https://cppreference.com/w/cpp/container/forward_list">&lt;forward_list&gt;</a> when referencing slist or stailq.</p>
<p>However, because BDS lists are intrusive and because they follow the BSD data structure design patterns, there are some differences when compared to normal C++ containers. These changes naturally cause some of the public interface to be different.</p>
<p>The fundamental difference is that BDS lists do not own their elements. A “list” object consists of a small “head” object which points to the first (and possibly last) item in the list. The items themselves have a lifetime distinct from the list head’s lifetime and are allocated elsewhere, usually in a memory pool. An illustration of a BDS <code class="docutils literal notranslate"><span class="pre">slist</span></code> is shown below:</p>
<div class="figure" id="id1">
<img alt="BDS slist datastructure diagram" src="_images/slist-diagram.png" />
<p class="caption"><span class="caption-text">A BDS list object is little more than a pointer to the intial item; the items are <em>not</em> owned by the list, they are only linked into it.</span></p>
</div>
<p>Compare this with node-based lists, like <code class="docutils literal notranslate"><span class="pre">std::forward_list</span></code>, which own their elements and store them in “node” containers. One possible implementation of this design is illustrated below:</p>
<div class="figure" id="id2">
<img alt="A typical node-based list datastructure" src="_images/node-list-diagram.png" />
<p class="caption"><span class="caption-text">A typical node-based list (i.e., a non-intrusive list) has ownership over the elements, which are typically wrapped inside node objects. The lifetime of node objects is explicitly managed by the list itself.</span></p>
</div>
<p>This fundamental difference gives rise to a variety of smaller API differences, be sure to read the section <a class="reference internal" href="lists-queue-and-stl.html#lists-diff-with-stl"><span class="std std-ref">Differences between BDS lists and other STL containers</span></a> for all the details.</p>
<ul class="simple">
<li>BDS lists cannot be copied.</li>
<li>List items are neither copied nor moved into the list – they are just added to it (their intrusive link member variable is modified to splice the item into the list).</li>
<li>As a consequence of the above, list items are always inserted <em>by pointer</em>, i.e., for a list of type <code class="docutils literal notranslate"><span class="pre">T</span></code>, the insert function requires a <code class="docutils literal notranslate"><span class="pre">T*</span></code> value. To avoid breaking with the standard containers too much, all other <em>non-insertion</em> member functions continue to use <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>, e.g., <code class="docutils literal notranslate"><span class="pre">front()</span></code> and <code class="docutils literal notranslate"><span class="pre">back()</span></code> return the item, not a pointer to it.</li>
<li>A list item cannot be added to multiple lists that use the same entry link.</li>
<li>The list destructor doesn’t actually destroy the items (because it does not own them).</li>
</ul>
<p>To balance out these limitations, BDS lists provide some useful APIs which are not in the standard containers – see <a class="reference internal" href="lists-queue-and-stl.html#lists-extra-methods"><span class="std std-ref">Methods in bds lists that do not exist in the STL</span></a>.</p>
</div>
<div class="section" id="choosing-the-template-parameters">
<h2><a class="toc-backref" href="#id6">Choosing the template parameters</a><a class="headerlink" href="#choosing-the-template-parameters" title="Permalink to this headline">¶</a></h2>
<p>As can be seen in the <a class="reference internal" href="#lists-main-example"><span class="std std-ref">example above</span></a> <code class="docutils literal notranslate"><span class="pre">slist_head</span></code> has three template parameters:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">T:</th><td class="field-body">The type of the items in the list.</td>
</tr>
<tr class="field-even field"><th class="field-name">EntryAccess:</th><td class="field-body">The type of function object that accesses the intrusive link, given an instance of <code class="docutils literal notranslate"><span class="pre">T</span></code>. In the example above, the intrusive link is the data member <code class="docutils literal notranslate"><span class="pre">bds::slist_entry</span> <span class="pre">link</span></code>. The link object is called an “entry” from the name of the corresponding <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> macros, e.g., <code class="docutils literal notranslate"><span class="pre">SLIST_ENTRY</span></code>. See <a class="reference internal" href="#lists-how-to-choose-entryaccess"><span class="std std-ref">Choosing the EntryAccess parameter</span></a> for more information.</td>
</tr>
<tr class="field-odd field"><th class="field-name">SizeType:</th><td class="field-body">The C++ standard container <code class="docutils literal notranslate"><span class="pre">&lt;list&gt;</span></code> offers <span class="math notranslate nohighlight">\(O(1)\)</span> access to its size by storing the list size inline and maintaining it during each modifying operation. The C++ standard container <code class="docutils literal notranslate"><span class="pre">&lt;forward_list&gt;</span></code>, and the BSD <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> library do not track list size – getting the size is an <span class="math notranslate nohighlight">\(O(n)\)</span> operation that fully traverses the list to count each item. BDS lists allow the user to choose which behavior they want. See <a class="reference internal" href="#lists-how-to-choose-sizetype"><span class="std std-ref">Choosing the SizeType Parameter</span></a> for more information.</td>
</tr>
</tbody>
</table>
<div class="section" id="choosing-the-entryaccess-parameter">
<span id="lists-how-to-choose-entryaccess"></span><h3><a class="toc-backref" href="#id7">Choosing the EntryAccess parameter</a><a class="headerlink" href="#choosing-the-entryaccess-parameter" title="Permalink to this headline">¶</a></h3>
<p>Although the user can provide any kind of function object (including a stateful one), most of the time you will use one of two special pre-defined functors:</p>
<div class="section" id="the-member-offset-functor">
<h4><a class="toc-backref" href="#id8">The member offset functor</a><a class="headerlink" href="#the-member-offset-functor" title="Permalink to this headline">¶</a></h4>
<p>This functor is declared as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">Offset</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">slist_entry_offset</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">slist_entry_offset</span></code> (along with its cousins, <code class="docutils literal notranslate"><span class="pre">stailq_entry_offset</span></code> and <code class="docutils literal notranslate"><span class="pre">tailq_entry_offset</span></code>) is a class template parameterized by a single <code class="docutils literal notranslate"><span class="pre">std::size_t</span></code> value, which should be the <code class="docutils literal notranslate"><span class="pre">offsetof</span></code> of the entry object in the type <code class="docutils literal notranslate"><span class="pre">T</span></code>. This functor is used in the <a class="reference internal" href="#lists-main-example"><span class="std std-ref">example above</span></a>.</p>
</div>
<div class="section" id="the-invocable-member-access-functor">
<h4><a class="toc-backref" href="#id9">The invocable/member-access functor</a><a class="headerlink" href="#the-invocable-member-access-functor" title="Permalink to this headline">¶</a></h4>
<p>This functor is declared as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">auto</span> <span class="n">I</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">constexpr_invocable</span><span class="p">;</span>
</pre></div>
</div>
<p>It wraps a compile-time-constant invocable (like a function member pointer, object member pointer, or free function pointer). The following example uses a function member pointer:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ListItem</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">bds</span><span class="o">::</span><span class="n">slist_entry</span> <span class="o">&amp;</span><span class="n">getLink</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">link</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">bds</span><span class="o">::</span><span class="n">slist_entry</span> <span class="n">link</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">list_t</span> <span class="o">=</span>
    <span class="n">bds</span><span class="o">::</span><span class="n">slist_head</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="p">,</span> <span class="n">constexpr_invocable</span><span class="o">&lt;&amp;</span><span class="n">ListItem</span><span class="o">::</span><span class="n">getLink</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>The implementation calls <code class="docutils literal notranslate"><span class="pre">std::invoke(&lt;invocable-template-argument&gt;,</span> <span class="pre">&lt;item-of-type-T&gt;)</span></code> to access the list entry. The <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">I</span></code> template argument is usually a member object pointer, a member function pointer, or a free function taking a single <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> argument (see the documentation of <a class="reference external" href="https://cppreference.com/w/cpp/utility/functional/invoke">std::invoke</a> for the possibilities).</p>
</div>
<div class="section" id="when-to-use-offset-based-vs-invocable-accessors">
<h4><a class="toc-backref" href="#id10">When to use offset-based vs. invocable accessors</a><a class="headerlink" href="#when-to-use-offset-based-vs-invocable-accessors" title="Permalink to this headline">¶</a></h4>
<p>Offset-based accessors usually result in better code generation, but not all types can support them. The C++ standard only guarantees that <code class="docutils literal notranslate"><span class="pre">offsetof</span></code> will work on standard layout types, although since C++17, implementations can choose to allow other types. Because of that freedom, BDS does not enforce the standard layout requirement through a template constraint, so the user must “know what they’re doing” when using <code class="docutils literal notranslate"><span class="pre">offsetof</span></code>.</p>
<p>Invocable accessors are more general, and can solve access protection problems. In some implementations, an <code class="docutils literal notranslate"><span class="pre">offsetof(T,</span> <span class="pre">&lt;field&gt;)</span></code> appearing outside of T and where <code class="docutils literal notranslate"><span class="pre">&lt;field&gt;</span></code> is non-public will fail, unless a friend declaration allows access in the scope where <code class="docutils literal notranslate"><span class="pre">offsetof</span></code> appears. Invocables can avoid this by using a public “getter” method to return a reference to the entry, as in the example above.</p>
<p>Both offset-based and <code class="docutils literal notranslate"><span class="pre">constexpr_invocable</span></code> functors are <a class="reference internal" href="intrusive-concepts.html#_CPPv3I0EN3bds9StatelessE" title="bds::Stateless"><code class="xref cpp cpp-concept docutils literal notranslate"><span class="pre">stateless</span></code></a>, and use no storage in the list object (thanks to a <code class="docutils literal notranslate"><span class="pre">[[no_unique_address]]</span></code> attribute). However, the user is free to add a stateful functor which can perform arbitrarily complex link access.</p>
</div>
</div>
<div class="section" id="choosing-the-sizetype-parameter">
<span id="lists-how-to-choose-sizetype"></span><h3><a class="toc-backref" href="#id11">Choosing the SizeType Parameter</a><a class="headerlink" href="#choosing-the-sizetype-parameter" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">SizeType</span></code> parameter can either be an integral type (in which case, the internal size member will be a field of that type) or it can be the special type <code class="docutils literal notranslate"><span class="pre">bds::no_size</span></code>, which removes the size member and gives the <span class="math notranslate nohighlight">\(O(n)\)</span> behavior.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">bds::no_size</span></code> behavior is more in-keeping with historical BSD design because typically, the size of most lists will not be greater than the maximum value of <code class="docutils literal notranslate"><span class="pre">std::uint32_t</span></code>. However, if <code class="docutils literal notranslate"><span class="pre">SizeType</span></code> is actually set to <code class="docutils literal notranslate"><span class="pre">std::uint32_t</span></code>, the user will probably waste 4 bytes of tail padding unless they are careful to pack small members immediately after the list head object. It will not be immediately clear from the code that valuable cache line space might be being wasted, so <code class="docutils literal notranslate"><span class="pre">bds::no_size</span></code> is generally preferred.</p>
<p>Because the list’s items are typically allocated from a pool allocator, there is usually a factory function which allocates items and places them on lists – this is a natural place for the user’s own size maintenance code.</p>
</div>
</div>
<div class="section" id="understanding-the-head-vs-fwd-head-container-templates">
<h2><a class="toc-backref" href="#id12">Understanding the <code class="docutils literal notranslate"><span class="pre">head</span></code> vs <code class="docutils literal notranslate"><span class="pre">fwd_head</span> <span class="pre">+</span> <span class="pre">container</span></code> templates</a><a class="headerlink" href="#understanding-the-head-vs-fwd-head-container-templates" title="Permalink to this headline">¶</a></h2>
<p>A BDS singly-linked list (slist) head can be created in one of two ways:</p>
<ol class="arabic simple">
<li>Using the <code class="docutils literal notranslate"><span class="pre">slist_head</span></code> class template</li>
<li>Using a combination of the <code class="docutils literal notranslate"><span class="pre">slist_fwd_head</span></code> and <code class="docutils literal notranslate"><span class="pre">slist_container</span></code> class templates</li>
</ol>
<p>Consider this code from the example above:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ListItem</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">bds</span><span class="o">::</span><span class="n">slist_entry</span> <span class="n">link</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">list_t</span> <span class="o">=</span>
    <span class="n">bds</span><span class="o">::</span><span class="n">slist_head</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="p">,</span> <span class="n">slist_entry_offset</span><span class="o">&lt;</span><span class="n">offsetof</span><span class="p">(</span><span class="n">ListItem</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">offsetof</span></code> macro requires <code class="docutils literal notranslate"><span class="pre">ListItem</span></code> to be a complete type. This means that the <code class="docutils literal notranslate"><span class="pre">list_t</span></code> type alias cannot be declared before the <code class="docutils literal notranslate"><span class="pre">ListItem</span></code> type is defined, nor can any instance of the list. That is, the following does <em>not</em> work:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ListItem</span><span class="p">;</span>

<span class="c1">// Error on the next line: offsetof into incomplete type `ListItem`</span>
<span class="k">using</span> <span class="n">list_t</span> <span class="o">=</span>
    <span class="n">bds</span><span class="o">::</span><span class="n">slist_head</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="p">,</span> <span class="n">slist_entry_offset</span><span class="o">&lt;</span><span class="n">offsetof</span><span class="p">(</span><span class="n">ListItem</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Definition is below, but it&#39;s too late!</span>
<span class="k">struct</span> <span class="n">ListItem</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">bds</span><span class="o">::</span><span class="n">slist_entry</span> <span class="n">link</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This restriction did not exist in the original <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> C library. In exchange, the <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> equivalent of the “entry access functor” (the name of the field for the link object) has to be specified in almost <em>every</em> macro that accesses the list, e.g., the <code class="docutils literal notranslate"><span class="pre">link</span></code> in <code class="docutils literal notranslate"><span class="pre">SLIST_INSERT_AFTER(item_before,</span> <span class="pre">item,</span> <span class="pre">link)</span></code>. BDS avoids this by baking the entry access details into the type definition, via a template argument. This is much friendlier API-wise, but requires the type to be complete.</p>
<p>If a list head must be declared before the item type is complete, it can be declared using the corresponding <code class="docutils literal notranslate"><span class="pre">_fwd_head</span></code> template, i.e., <code class="docutils literal notranslate"><span class="pre">slist_fwd_head</span></code>. This is a template only requires the <code class="docutils literal notranslate"><span class="pre">SizeType</span></code> template parameter.</p>
<p>To actually use the list, the proxy type <code class="docutils literal notranslate"><span class="pre">slist_container</span></code> is constructed, taking a reference to the <code class="docutils literal notranslate"><span class="pre">slist_fwd_head</span></code>, and imbuing it with the <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">EntryAccess</span></code> template parameters.</p>
<p>A code example illustrates this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ListItem</span><span class="p">;</span> <span class="c1">// Note: not complete yet</span>

<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="n">bds</span><span class="o">::</span><span class="n">stailq_fwd_head</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">allItemsFwd</span><span class="p">;</span> <span class="c1">// Collection of ListItems</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ListItem</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">bds</span><span class="o">::</span><span class="n">slist_entry</span> <span class="n">link</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Now that ListItem is a complete type, define `list_t` as an `slist_container`</span>
<span class="c1">// instead of `slist_head`.</span>
<span class="k">using</span> <span class="n">list_t</span> <span class="o">=</span>
    <span class="n">bds</span><span class="o">::</span><span class="n">slist_container</span><span class="o">&lt;</span><span class="n">ListItem</span><span class="p">,</span> <span class="n">slist_entry_offset</span><span class="o">&lt;</span><span class="n">offsetof</span><span class="p">(</span><span class="n">ListItem</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">printItems</span><span class="p">(</span><span class="n">S</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Construct a list_t proxy container, passing in the head object.</span>
  <span class="n">list_t</span> <span class="n">allItems</span><span class="p">{</span><span class="n">s</span><span class="p">.</span><span class="n">allItemsFwd</span><span class="p">};</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">ListItem</span> <span class="o">&amp;</span><span class="nl">item</span> <span class="p">:</span> <span class="n">allItems</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;This is item #&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The “container” types are extremely cheap to construct (for stateless entry accessors, they only capture a reference to “forward head”) and should be completely elided at higher optimization levels. They are also implicitly constructible from the corresponding <code class="docutils literal notranslate"><span class="pre">fwd_head</span></code> type, so the user can often avoid explicitly constructing them, e.g.:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">printItems</span><span class="p">(</span><span class="k">const</span> <span class="n">list_t</span> <span class="o">&amp;</span><span class="n">allItems</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">S</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printItems</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">allItemsFwd</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The (somewhat awkward) need to construct a proxy object each time is roughly analogous to the need to specify the link member each time in the old <code class="docutils literal notranslate"><span class="pre">queue(3)</span></code> macros. Thus, when you don’t need the flexibility of the <code class="docutils literal notranslate"><span class="pre">_container</span></code> variant, prefer the <code class="docutils literal notranslate"><span class="pre">_head</span></code> version.</p>
</div>
<div class="section" id="understand-the-bds-list-concepts">
<h2><a class="toc-backref" href="#id13">Understand the BDS list concepts</a><a class="headerlink" href="#understand-the-bds-list-concepts" title="Permalink to this headline">¶</a></h2>
<p>Most of the implementation of an slist is contained in the class template <code class="docutils literal notranslate"><span class="pre">slist_base</span></code>. Both <code class="docutils literal notranslate"><span class="pre">slist_head</span></code> and <code class="docutils literal notranslate"><span class="pre">slist_container</span></code> inherit the core slist API from this (<a class="reference external" href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a>) base class. The only difference between <code class="docutils literal notranslate"><span class="pre">slist_head</span></code> and <code class="docutils literal notranslate"><span class="pre">slist_container</span></code> is that the former is a bit simpler, but at the expense of requiring complete types.</p>
<p>A function taking any kind of slist could be defined like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">EntryAccess</span><span class="p">,</span> <span class="k">typename</span> <span class="n">SizeType</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">bds</span><span class="o">::</span><span class="n">slist_base</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">EntryAccess</span><span class="p">,</span> <span class="n">SizeType</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">anySList</span><span class="p">);</span>
</pre></div>
</div>
<p>With C++20 concepts, a better option is available:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">bds</span><span class="o">::</span><span class="n">SList</span> <span class="n">ListType</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ListType</span> <span class="o">&amp;</span><span class="n">anySList</span><span class="p">);</span>
</pre></div>
</div>
<p>The single-argument concepts <code class="docutils literal notranslate"><span class="pre">TailQ</span></code>, <code class="docutils literal notranslate"><span class="pre">STailQ</span></code>, and <code class="docutils literal notranslate"><span class="pre">SList</span></code> evaluate to true if the given type argument is a BDS list of the appropriate kind. The concept <code class="docutils literal notranslate"><span class="pre">SListOrQueue</span></code> can be used to check for either <code class="docutils literal notranslate"><span class="pre">STailQ</span></code> or <code class="docutils literal notranslate"><span class="pre">SList</span></code>, which have similar APIs because they are both singly-linked lists.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lists-rationale.html" class="btn btn-neutral float-right" title="Why Intrusive Lists?" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lists-main.html" class="btn btn-neutral" title="Lists Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Kenneth Camann.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2018.1-alpha1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>